import { sql } from "drizzle-orm";
import { pgTable, text, varchar, integer, boolean, jsonb, timestamp } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

// Cohorts table for managing access groups
export const cohorts = pgTable("cohorts", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  code: varchar("code", { length: 8 }).notNull().unique(), // 8-character unique access code (supports 6-8 digit codes)
  name: text("name").notNull(), // Admin-friendly name for the cohort
  description: text("description"), // Optional description
  allowedSlots: integer("allowed_slots").notNull(), // Maximum number of members
  usedSlots: integer("used_slots").notNull().default(0), // Current number of members
  status: text("status").notNull().default("active"), // active, inactive
  createdAt: text("created_at").default(sql`now()`),
});

// Users table for cohort membership and admin roles
export const users = pgTable("users", {
  userId: text("user_id").primaryKey(), // Firebase UID
  email: text("email").notNull(),
  cohortId: varchar("cohort_id").references(() => cohorts.id),
  role: text("role").notNull().default("user"), // user, admin, super_admin
  lastActiveAt: text("last_active_at"),
  invitedBy: text("invited_by"), // Track who invited admin users (no FK for now to avoid circular ref)
  createdAt: text("created_at").default(sql`now()`),
});

export const assessments = pgTable("assessments", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: text("user_id").notNull().references(() => users.userId), // Firebase user ID for ownership tracking
  contextProfile: jsonb("context_profile").notNull(),
  situationAssessment: jsonb("context_mirror"),
  situationAssessmentUpdatedAt: text("context_mirror_updated_at"),
  pulseResponses: jsonb("pulse_responses"),
  pillarScores: jsonb("pillar_scores"),
  confidenceGaps: jsonb("confidence_gaps"),
  triggeredGates: jsonb("triggered_gates"),
  priorityMoves: jsonb("priority_moves"),
  contentTags: jsonb("content_tags"),
  contextGuidance: jsonb("context_guidance"),
  valueOverlay: jsonb("value_overlay"),
  optionsStudioSession: jsonb("options_studio_session"),
  completedAt: text("completed_at"),
  createdAt: text("created_at").default(sql`now()`),
});

// Bootstrap invites table for reusable super admin access codes
export const bootstrapInvites = pgTable("bootstrap_invites", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  code: varchar("code", { length: 8 }).notNull().unique(), // Bootstrap access code (e.g., F9K2B7QX)
  role: text("role").notNull().default("super_admin"), // Role to assign when code is used
  allowedUses: integer("allowed_uses").notNull().default(1), // Maximum number of times this code can be used
  remainingUses: integer("remaining_uses").notNull().default(1), // Current remaining uses
  expiresAt: timestamp("expires_at").notNull(), // When this invite expires
  issuedBy: text("issued_by").notNull().references(() => users.userId), // Who created this invite
  description: text("description"), // Optional description for audit purposes
  status: text("status").notNull().default("active"), // active, expired, revoked
  createdAt: text("created_at").default(sql`now()`),
  lastUsedAt: text("last_used_at"), // Track when it was last used
  usedBy: jsonb("used_by").default('[]'), // Array of user IDs who used this code (for audit)
});

// Insert schemas and types for new tables
export const insertCohortSchema = createInsertSchema(cohorts).omit({
  id: true,
  code: true, // This is autogenerated by the system
  createdAt: true,
  usedSlots: true, // This is managed by the system
});

export const insertUserSchema = createInsertSchema(users).omit({
  createdAt: true,
});

export const insertAssessmentSchema = createInsertSchema(assessments).omit({
  id: true,
  createdAt: true,
});

export const insertBootstrapInviteSchema = createInsertSchema(bootstrapInvites).omit({
  id: true,
  createdAt: true,
  lastUsedAt: true,
  usedBy: true,
});

export type InsertCohort = z.infer<typeof insertCohortSchema>;
export type Cohort = typeof cohorts.$inferSelect;
export type InsertUser = z.infer<typeof insertUserSchema>;
export type User = typeof users.$inferSelect;
export type InsertAssessment = z.infer<typeof insertAssessmentSchema>;
export type Assessment = typeof assessments.$inferSelect;
export type InsertBootstrapInvite = z.infer<typeof insertBootstrapInviteSchema>;
export type BootstrapInvite = typeof bootstrapInvites.$inferSelect;

// Context Profile Types
export const contextProfileSchema = z.object({
  regulatory_intensity: z.number().min(0).max(4),
  data_sensitivity: z.number().min(0).max(4),
  safety_criticality: z.number().min(0).max(4),
  brand_exposure: z.number().min(0).max(4),
  clock_speed: z.number().min(0).max(4),
  latency_edge: z.number().min(0).max(4),
  scale_throughput: z.number().min(0).max(4),
  data_advantage: z.number().min(0).max(4),
  build_readiness: z.number().min(0).max(4),
  finops_priority: z.number().min(0).max(4),
  procurement_constraints: z.boolean(),
  edge_operations: z.boolean(),
});

export type ContextProfile = z.infer<typeof contextProfileSchema>;

// Pulse Check Types - supports numeric scoring (0, 0.25, 0.5, 1) for No/Started/Mostly/Yes
export const pulseResponsesSchema = z.record(
  z.string(), 
  z.union([z.literal(0), z.literal(0.25), z.literal(0.5), z.literal(1)])
);
export type PulseResponses = z.infer<typeof pulseResponsesSchema>;

// Pillar Scores
export const pillarScoresSchema = z.object({
  C: z.number().min(0).max(3),
  O: z.number().min(0).max(3),
  R: z.number().min(0).max(3),
  T: z.number().min(0).max(3),
  E: z.number().min(0).max(3),
  X: z.number().min(0).max(3),
});

export type PillarScores = z.infer<typeof pillarScoresSchema>;

// Confidence Gaps - tracks count of "Unsure" responses per pillar (0-3)
export const confidenceGapsSchema = z.object({
  C: z.number().min(0).max(3),
  O: z.number().min(0).max(3),
  R: z.number().min(0).max(3),
  T: z.number().min(0).max(3),
  E: z.number().min(0).max(3),
  X: z.number().min(0).max(3),
});

export type ConfidenceGaps = z.infer<typeof confidenceGapsSchema>;

// Gate Types
export const gateSchema = z.object({
  id: z.string(),
  title: z.string(),
  triggered: z.boolean(),
  reason: z.string(),
});

export type Gate = z.infer<typeof gateSchema>;

// Value Overlay Types
export const valueOverlayPillarSchema = z.object({
  metric_id: z.string(),
  name: z.string(),
  baseline: z.number().nullable(),
  target: z.number().nullable(),
  unit: z.string(),
  cadence: z.enum(['monthly', 'quarterly']),
});

export const valueOverlaySchema = z.object({
  C: valueOverlayPillarSchema.optional(),
  O: valueOverlayPillarSchema.optional(),
  R: valueOverlayPillarSchema.optional(),
  T: valueOverlayPillarSchema.optional(),
  E: valueOverlayPillarSchema.optional(),
  X: valueOverlayPillarSchema.optional(),
});

export type ValueOverlayPillar = z.infer<typeof valueOverlayPillarSchema>;
export type ValueOverlay = z.infer<typeof valueOverlaySchema>;

// Situation Assessment Types - Enhanced 2.0 format with executive dashboard structure
export const situationAssessmentSchema = z.object({
  // Legacy structured format (for backward compatibility)
  strengths: z.array(z.string().min(8).max(180)).length(3).optional(),
  fragilities: z.array(z.string().min(8).max(180)).length(3).optional(),
  whatWorks: z.array(z.string().min(10).max(180)).length(2).optional(),
  disclaimer: z.string().min(10).max(140),
  
  // Narrative format (current)
  insight: z.string().min(50).optional(), // Two paragraphs of 150-220 words total
  
  // Situation Assessment 2.0 - Executive Dashboard Format
  headline: z.string().max(120).optional(),
  actions: z.array(z.string().max(84)).length(3).optional(), // ≤14 words each (~6 chars/word)
  watchouts: z.array(z.string().max(84)).length(2).optional(), // ≤14 words each
  scenarios: z.object({
    if_regulation_tightens: z.string().optional(),
    if_budgets_tighten: z.string().optional(),
  }).optional(),
});

export type SituationAssessment = z.infer<typeof situationAssessmentSchema>;

// Situation Assessment Payload (Enhanced 2.0 format)
export const situationAssessmentPayloadSchema = z.object({
  headline: z.string().max(120),                           // ≤120 chars executive takeaway
  insight: z.string(),                                     // two paragraphs separated by \n\n
  actions: z.array(z.string().max(84)).length(3),         // 3 concise actions (≤14 words each)
  watchouts: z.array(z.string().max(84)).length(2),       // 2 concise risks (≤14 words each)
  scenarios: z.object({
    if_regulation_tightens: z.string(),                    // one sentence scenario
    if_budgets_tighten: z.string(),                        // one sentence scenario
  }),
  disclaimer: z.string(),                                  // one-line micro-disclaimer
});

export type SituationAssessmentPayload = z.infer<typeof situationAssessmentPayloadSchema>;

// Situation Assessment Request Validation Schema
export const situationAssessmentRequestSchema = z.object({
  assessmentId: z.string().uuid("Assessment ID must be a valid UUID"),
});

export type SituationAssessmentRequest = z.infer<typeof situationAssessmentRequestSchema>;

// Diagnostic Metadata Types for AI Generation Transparency
export const generationAttemptSchema = z.object({
  attemptNumber: z.number().int().min(1),
  model: z.string(),
  startTime: z.string(),
  endTime: z.string().optional(),
  duration: z.number().min(0).optional(), // milliseconds
  success: z.boolean(),
  failureReason: z.enum(['timeout', 'policy_violation', 'parse_error', 'api_error', 'unknown']).optional(),
  rawResponse: z.string().optional(), // First 500 chars for debugging
  policyViolation: z.boolean().optional(),
  parseError: z.string().optional(),
});

export const generationMetadataSchema = z.object({
  source: z.enum(['ai', 'fallback', 'retry-fallback']),
  attempts: z.array(generationAttemptSchema),
  finalSource: z.enum(['ai', 'template']),
  templateUsed: z.string().optional(), // Template identifier if fallback was used
  totalDuration: z.number().min(0), // Total milliseconds from start to finish
  modelVersion: z.string().optional(),
  generatedAt: z.string(), // ISO timestamp
});

export type GenerationAttempt = z.infer<typeof generationAttemptSchema>;
export type GenerationMetadata = z.infer<typeof generationMetadataSchema>;

// Enhanced Situation Assessment Response with Diagnostic Data
export const situationAssessmentWithDiagnosticsSchema = situationAssessmentPayloadSchema.extend({
  debug: generationMetadataSchema,
});

export type SituationAssessmentWithDiagnostics = z.infer<typeof situationAssessmentWithDiagnosticsSchema>;

// Options Studio Types - Seven Lenses Framework
export const lensPositionsSchema = z.object({
  speed: z.number().int().min(0).max(4),               // Speed-to-Value: 0=months+; 2=weeks; 4=days
  control: z.number().int().min(0).max(4),             // Customization & Control: 0=out-of-box; 4=deeply tailored
  dataLeverage: z.number().int().min(0).max(4),        // Data Leverage: 0=doesn't use your data; 4=strong proprietary use
  riskLoad: z.number().int().min(0).max(4),            // Risk & Compliance Load: 0=minimal controls; 4=heavy governance
  opsBurden: z.number().int().min(0).max(4),           // Operational Burden: 0=near zero ops; 4=dedicated team
  portability: z.number().int().min(0).max(4),         // Portability & Lock-in: 0=hard to switch; 4=easy to migrate
  costShape: z.number().int().min(0).max(4),           // Cost Shape: 0=heavy fixed/CapEx; 4=variable/throttleable OpEx
});

export const timelineMetersSchema = z.object({
  speed: z.number().int().min(0).max(4),
  buildEffort: z.number().int().min(0).max(4),
  ops: z.number().int().min(0).max(4),
});

export const mythSchema = z.object({
  claim: z.string(),
  truth: z.string(),
});

export const optionCardSchema = z.object({
  id: z.string(),
  title: z.string(),
  what: z.string(),                              // What this option is
  bestFor: z.array(z.string()),                  // 3-5 bullets of when to use
  notIdeal: z.array(z.string()),                 // 2-4 bullets of when not to use
  prerequisites: z.array(z.string()),            // 3-5 bullets of what's needed
  timelineMeters: timelineMetersSchema,
  dataNeeds: z.string(),                         // 1-2 sentences about data requirements
  risks: z.array(z.string()),                    // 3-5 bullets of key risks
  kpis: z.array(z.string()),                     // 2-3 bullets of success metrics
  myth: mythSchema,                              // Common misconception and truth
  axes: lensPositionsSchema,                     // Seven Lenses positioning
  cautions: z.array(z.enum(['regulated', 'high_sensitivity', 'low_readiness', 'edge'])).optional(),
});

// Extended option card for UI with computed properties
export interface ExtendedOptionCard extends z.infer<typeof optionCardSchema> {
  lensValues: LensPositions;
  category: string;
  shortDescription: string;
  fullDescription: string;
  pros: string[];
  cons: string[];
  examples: string[];
  question?: string; // For misconception questions
}

// Helper function to categorize options by readiness level
export function categorizeByReadiness(option: z.infer<typeof optionCardSchema>): string {
  // Categorize based on speed and build effort from timelineMeters
  const { speed, buildEffort } = option.timelineMeters;
  if (speed >= 3 && buildEffort <= 2) return 'ready';
  if (buildEffort >= 3) return 'build';
  return 'custom';
}

// Helper function to extend option card with UI properties
export function extendOptionCard(card: z.infer<typeof optionCardSchema>): ExtendedOptionCard {
  return {
    ...card,
    lensValues: card.axes,
    category: categorizeByReadiness(card),
    shortDescription: card.what,
    fullDescription: card.what,
    pros: card.bestFor,
    cons: card.notIdeal,
    examples: [],
  };
}

// Helper function to extend misconception question with UI properties
export function extendMisconceptionQuestion(question: z.infer<typeof misconceptionQuestionSchema>): z.infer<typeof misconceptionQuestionSchema> {
  return question;
}

export const misconceptionQuestionSchema = z.object({
  id: z.string(),
  question: z.string(),                          // The misconception statement as a question
  correctAnswer: z.boolean(),                    // True/False for the statement
  explanation: z.string(),                       // Why the answer is correct
  links: z.array(z.string()),                    // Related option IDs
});

export const optionsStudioSessionSchema = z.object({
  useCase: z.string(),
  goals: z.array(z.string()),
  misconceptionResponses: z.record(z.string(), z.boolean()),
  comparedOptions: z.array(z.string()),
  reflectionPrompts: z.array(z.string()),
  completed: z.boolean(),
  completedAt: z.string().optional(),
});

export type LensPositions = z.infer<typeof lensPositionsSchema>;
export type LensValues = LensPositions; // Alias for backwards compatibility
export type TimelineMeters = z.infer<typeof timelineMetersSchema>;
export type Myth = z.infer<typeof mythSchema>;
export type OptionCard = z.infer<typeof optionCardSchema>;
export type MisconceptionQuestion = z.infer<typeof misconceptionQuestionSchema>;
export type OptionsStudioSession = z.infer<typeof optionsStudioSessionSchema>;

// Validation function for runtime checking
export function validateOptionCards(cards: unknown): OptionCard[] {
  return z.array(optionCardSchema).parse(cards);
}

export function validateMisconceptionQuestions(questions: unknown): MisconceptionQuestion[] {
  return z.array(misconceptionQuestionSchema).parse(questions);
}
